package main

import (
	"crypto/sha256"
	"encoding/hex"
	"fmt"
)

type NavierStokesFourier struct {
	u         [][]float64
	viscosity float64
	density   float64
}

func NewNavierStokesFourier(gridSize int, viscosity float64, density float64) *NavierStokesFourier {
	u := make([][]float64, gridSize)
	for i := range u {
		u[i] = make([]float64, gridSize)
	}
	return &NavierStokesFourier{
		u:         u,
		viscosity: viscosity,
		density:   density,
	}
}

func (nsf *NavierStokesFourier) UpdateVelocityField() {
	gridSize := len(nsf.u)
	laplacian := make([][]float64, gridSize)
	for i := range laplacian {
		laplacian[i] = make([]float64, gridSize)
	}

	for i := 1; i < gridSize-1; i++ {
		for j := 1; j < gridSize-1; j++ {
			laplacian[i][j] =
				nsf.u[i+1][j] + nsf.u[i-1][j] + nsf.u[i][j+1] + nsf.u[i][j-1] - 4*nsf.u[i][j]
		}
	}

	for i := 0; i < gridSize; i++ {
		for j := 0; j < gridSize; j++ {
			nsf.u[i][j] += nsf.viscosity * laplacian[i][j] / nsf.density
		}
	}
}

func (nsf *NavierStokesFourier) HashVelocityField() string {
	data := fmt.Sprintf("%v", nsf.u)
	hash := sha256.Sum256([]byte(data))
	return hex.EncodeToString(hash[:])
}

func main() {
	nsf := NewNavierStokesFourier(50, 0.1, 1.0)
	nsf.UpdateVelocityField()
	fmt.Println("Velocity Field Hash:", nsf.HashVelocityField())
}
