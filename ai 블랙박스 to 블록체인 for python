import numpy as np
import hashlib
import matplotlib.pyplot as plt
from sklearn.decomposition import PCA
from tensorflow import keras
import tensorflow as tf

class TransparentAIModel:
    """
    AI 모델의 투명성을 향상시키기 위한 래퍼 클래스
    - 의사결정 경로 및 특징 중요도를 추적하고 로그로 기록
    - 블록체인과 연계하여 예측 결과를 안전하게 저장
    """
    def __init__(self, model, feature_names=None):
        self.model = model  # AI 모델 저장
        self.feature_names = feature_names  # 특징 이름 저장
        self.decision_history = []  # 의사결정 기록 저장
        self.feature_importance = {}  # 특징 중요도 저장
        self.hash_history = []  # 해시 기록 저장
        
    def compute_feature_importance(self, X, y):
        """
        특징 중요도를 계산하는 함수 (Permutation 방법 사용)
        """
        base_score = self.model.evaluate(X, y, verbose=0)  # 원래 성능 평가
        importance = {}
        
        for i in range(X.shape[1]):
            orig_values = X[:, i].copy()  # 원래 값 저장
            np.random.shuffle(X[:, i])  # 해당 특징을 무작위로 섞음
            new_score = self.model.evaluate(X, y, verbose=0)  # 변형된 데이터로 평가
            X[:, i] = orig_values  # 원래 값 복원
            
            importance[i] = new_score - base_score  # 성능 감소량을 중요도로 설정
            
            # 특징 이름이 주어졌다면 이름을 사용, 없으면 인덱스를 사용
            if self.feature_names and i < len(self.feature_names):
                name = self.feature_names[i]
                self.feature_importance[name] = importance[i]
            else:
                self.feature_importance[f"feature_{i}"] = importance[i]
                
        return importance
        
    def explain_prediction(self, X_sample):
        """
        특정 샘플에 대한 예측을 설명하는 함수
        """
        prediction = self.model.predict(X_sample)
        
        if isinstance(self.model, keras.Model):  # 모델이 Keras 모델인지 확인
            layer_outputs = []
            activation_model = keras.Model(
                inputs=self.model.input,
                outputs=[layer.output for layer in self.model.layers]
            )
            activations = activation_model.predict(X_sample)
            
            for i, activation in enumerate(activations):
                layer_outputs.append({
                    "layer": self.model.layers[i].name,
                    "activation_summary": {
                        "mean": float(np.mean(activation)),
                        "std": float(np.std(activation)),
                        "min": float(np.min(activation)),
                        "max": float(np.max(activation))
                    }
                })
                
            # 레이어 출력을 해시값으로 저장
            hash_value = self.hash_layer_outputs(layer_outputs)
            self.hash_history.append(hash_value)
            
            explanation = {
                "prediction": prediction.tolist(),
                "layer_activations": layer_outputs,
                "hash": hash_value
            }
            
            self.decision_history.append(explanation)
            return explanation
        else:
            return {"prediction": prediction.tolist()}
            
    def hash_layer_outputs(self, layer_outputs):
        """
        레이어 출력값을 해시로 변환하여 블록체인 저장용으로 변환
        """
        output_str = str(layer_outputs)
        return hashlib.sha256(output_str.encode()).hexdigest()
        
    def visualize_decision_boundary(self, X, y, feature_idx1=0, feature_idx2=1):
        """
        두 개의 특징에 대한 의사결정 경계를 시각화하는 함수
        """
        if X.shape[1] > 2:
            pca = PCA(n_components=2)  # PCA를 사용해 차원 축소
            X_reduced = pca.fit_transform(X)
        else:
            X_reduced = X.copy()
            
        # 격자(grid) 생성
        h = 0.01
        x_min, x_max = X_reduced[:, 0].min() - 1, X_reduced[:, 0].max() + 1
        y_min, y_max = X_reduced[:, 1].min() - 1, X_reduced[:, 1].max() + 1
        xx, yy = np.meshgrid(np.arange(x_min, x_max, h),
                             np.arange(y_min, y_max, h))
        
        # 격자 데이터에 대한 예측 수행
        if X.shape[1] > 2:
            grid = np.c_[xx.ravel(), yy.ravel()]
            grid_orig = pca.inverse_transform(grid)
            Z = self.model.predict(grid_orig)
        else:
            Z = self.model.predict(np.c_[xx.ravel(), yy.ravel()])
            
        Z = Z.reshape(xx.shape)
        
        # 의사결정 경계 시각화
        plt.figure(figsize=(10, 8))
        plt.contourf(xx, yy, Z, alpha=0.8)
        plt.scatter(X_reduced[:, 0], X_reduced[:, 1], c=y, edgecolors='k')
        
        if self.feature_names and len(self.feature_names) >= 2:
            plt.xlabel(self.feature_names[feature_idx1])
            plt.ylabel(self.feature_names[feature_idx2])
        else:
            plt.xlabel(f"Feature {feature_idx1}")
            plt.ylabel(f"Feature {feature_idx2}")
            
        plt.title("의사결정 경계 시각화")
        return plt

class BlockchainLogger:
    """
    블록체인 기술을 활용하여 AI 모델의 예측 및 설명을 안전하게 저장하는 클래스
    """
    def __init__(self):
        self.chain = []
        self.create_genesis_block()
        
    def create_genesis_block(self):
        """
        블록체인의 첫 번째 블록(제네시스 블록) 생성
        """
        genesis_block = {
            'index': 0,
            'timestamp': np.datetime64('now'),
            'data': "Genesis Block",
            'previous_hash': "0",
            'hash': self.hash_block("Genesis Block" + "0")
        }
        self.chain.append(genesis_block)
        
    def hash_block(self, block_data):
        """
        블록 데이터를 SHA-256 해시로 변환
        """
        if isinstance(block_data, dict):
            block_data = str(block_data)
        return hashlib.sha256(block_data.encode()).hexdigest()
        
    def add_block(self, data):
        """
        새로운 블록을 체인에 추가
        """
        previous_block = self.chain[-1]
        new_block = {
            'index': previous_block['index'] + 1,
            'timestamp': np.datetime64('now'),
            'data': data,
            'previous_hash': previous_block['hash'],
            'hash': None
        }
        new_block['hash'] = self.hash_block(str(new_block))
        self.chain.append(new_block)
        return new_block
